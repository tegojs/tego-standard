name: Sync Changelog to Docs Repository

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to sync (e.g., v1.5.1)'
        required: false
        type: string
      docs_repo:
        description: 'Documentation repository (e.g., tegojs/docs)'
        required: false
        type: string
  workflow_call:
    inputs:
      version:
        description: 'Version to sync (e.g., v1.5.1)'
        required: false
        type: string
      docs_repo:
        description: 'Documentation repository (e.g., tegojs/docs)'
        required: false
        type: string
    secrets:
      DOCS_REPOSITORY:
        required: false
      DOCS_REPO_TOKEN:
        required: false
      DOCS_CHANGELOG_EN_PATH:
        required: false
      DOCS_CHANGELOG_ZH_PATH:
        required: false

run-name: "Sync Changelog - Version: ${{ github.ref_name || inputs.version || github.event.inputs.version }}"

jobs:
  sync-changelog:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: source

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ inputs.version || github.event.inputs.version }}" ]; then
            VERSION="${{ inputs.version || github.event.inputs.version }}"
          elif [ -n "${{ github.ref_name }}" ]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION=$(node -p "require('./source/package.json').version")
            VERSION="v${VERSION}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version to sync: ${VERSION}"

      - name: Extract changelog entries
        id: extract_changelog
        run: |
          cd source

          VERSION="${{ steps.version.outputs.version }}"
          VERSION_NUMBER=${VERSION#v}

          # Check if syncing Unreleased section
          if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
            echo "Syncing [Unreleased] section"

            # Extract [Unreleased] section from CHANGELOG.md
            if [ -f "CHANGELOG.md" ]; then
              awk '
                /^## \[Unreleased\]/ {
                  print_section = 1
                  print $0
                  next
                }
                print_section {
                  if (/^## \[/) {
                    exit
                  }
                  print
                }
              ' CHANGELOG.md > /tmp/changelog_en.md || echo "" > /tmp/changelog_en.md
            else
              echo "" > /tmp/changelog_en.md
            fi

            # Extract [未发布] section from CHANGELOG.zh-CN.md
            if [ -f "CHANGELOG.zh-CN.md" ]; then
              awk '
                /^## \[未发布\]/ {
                  print_section = 1
                  print $0
                  next
                }
                print_section {
                  if (/^## \[/) {
                    exit
                  }
                  print
                }
              ' CHANGELOG.zh-CN.md > /tmp/changelog_zh.md || echo "" > /tmp/changelog_zh.md
            else
              echo "" > /tmp/changelog_zh.md
            fi
          else
            # Extract changelog entry for this version from CHANGELOG.md
            if [ -f "CHANGELOG.md" ]; then
              awk -v version="$VERSION_NUMBER" '
                /^## \[/ {
                  if ($0 ~ "\\[" version "\\]") {
                    print_section = 1
                    print $0
                    next
                  } else if (print_section && /^## \[/) {
                    exit
                  }
                }
                print_section { print }
              ' CHANGELOG.md > /tmp/changelog_en.md || echo "" > /tmp/changelog_en.md
            else
              echo "" > /tmp/changelog_en.md
            fi

            # Extract changelog entry for this version from CHANGELOG.zh-CN.md
            if [ -f "CHANGELOG.zh-CN.md" ]; then
              awk -v version="$VERSION_NUMBER" '
                /^## \[/ {
                  if ($0 ~ "\\[" version "\\]") {
                    print_section = 1
                    print $0
                    next
                  } else if (print_section && /^## \[/) {
                    exit
                  }
                }
                print_section { print }
              ' CHANGELOG.zh-CN.md > /tmp/changelog_zh.md || echo "" > /tmp/changelog_zh.md
            else
              echo "" > /tmp/changelog_zh.md
            fi
          fi

          # Check if changelog entries exist (more than just empty lines)
          EN_LINES=$(cat /tmp/changelog_en.md | grep -v '^[[:space:]]*$' | wc -l)
          ZH_LINES=$(cat /tmp/changelog_zh.md | grep -v '^[[:space:]]*$' | wc -l)

          if [ "$EN_LINES" -gt 1 ] || [ "$ZH_LINES" -gt 1 ]; then
            echo "has_changelog=true" >> $GITHUB_OUTPUT
            echo "Found changelog entries: EN($EN_LINES lines), ZH($ZH_LINES lines)"
          else
            echo "has_changelog=false" >> $GITHUB_OUTPUT
            if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
              echo "No [Unreleased] entries found"
            else
              echo "No changelog entries found for version $VERSION_NUMBER"
            fi
          fi

      - name: Checkout docs repository
        if: steps.extract_changelog.outputs.has_changelog == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.docs_repo || github.event.inputs.docs_repo || secrets.DOCS_REPOSITORY || 'tegojs/docs' }}
          # Note: GITHUB_TOKEN cannot access cross-repository, must use DOCS_REPO_TOKEN (PAT)
          token: ${{ secrets.DOCS_REPO_TOKEN || secrets.GITHUB_TOKEN }}
          path: docs
          fetch-depth: 1
          ref: main

      - name: Setup Git
        if: steps.extract_changelog.outputs.has_changelog == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Sync changelog to docs repository
        if: steps.extract_changelog.outputs.has_changelog == 'true'
        env:
          DOCS_CHANGELOG_EN_PATH: ${{ secrets.DOCS_CHANGELOG_EN_PATH || 'docs/en/changelog/changelog.md' }}
          DOCS_CHANGELOG_ZH_PATH: ${{ secrets.DOCS_CHANGELOG_ZH_PATH || 'docs/zh/changelog/changelog.md' }}
          DOCS_REPO_TOKEN: ${{ secrets.DOCS_REPO_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          cd docs

          VERSION="${{ steps.version.outputs.version }}"
          VERSION_NUMBER=${VERSION#v}
          IS_UNRELEASED=false

          if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
            IS_UNRELEASED=true
          fi

          # Determine target file paths
          EN_TARGET="${DOCS_CHANGELOG_EN_PATH}"
          ZH_TARGET="${DOCS_CHANGELOG_ZH_PATH}"

          # Create directories if they don't exist
          mkdir -p "$(dirname "${EN_TARGET}")"
          mkdir -p "$(dirname "${ZH_TARGET}")"

          if [ "$IS_UNRELEASED" == "true" ]; then
            # For Unreleased section, replace the entire section at the beginning
            # Append English changelog (only if it has content)
            if [ -s /tmp/changelog_en.md ] && [ "$(cat /tmp/changelog_en.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              if [ -f "${EN_TARGET}" ]; then
                # Replace [Unreleased] section if exists, otherwise prepend
                if grep -q "^## \[Unreleased\]" "${EN_TARGET}"; then
                  # Replace existing [Unreleased] section
                  # Remove everything from "## [Unreleased]" to the next "## [" (exclusive)
                  awk '
                    BEGIN { in_unreleased = 0 }
                    /^## \[Unreleased\]/ { in_unreleased = 1; next }
                    in_unreleased && /^## \[/ { in_unreleased = 0 }
                    !in_unreleased { print }
                  ' "${EN_TARGET}" > /tmp/changelog_en_temp.md
                  # Prepend new [Unreleased] content
                  cat /tmp/changelog_en.md > "${EN_TARGET}"
                  echo "" >> "${EN_TARGET}"
                  cat /tmp/changelog_en_temp.md >> "${EN_TARGET}"
                else
                  # Prepend [Unreleased] section
                  cat /tmp/changelog_en.md > /tmp/changelog_en_new.md
                  echo "" >> /tmp/changelog_en_new.md
                  cat "${EN_TARGET}" >> /tmp/changelog_en_new.md
                  mv /tmp/changelog_en_new.md "${EN_TARGET}"
                fi
              else
                # Create new file
                cat /tmp/changelog_en.md > "${EN_TARGET}"
              fi
              echo "✓ Synced English [Unreleased] changelog to ${EN_TARGET}"
            fi

            # Append Chinese changelog (only if it has content)
            if [ -s /tmp/changelog_zh.md ] && [ "$(cat /tmp/changelog_zh.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              if [ -f "${ZH_TARGET}" ]; then
                # Replace [未发布] section if exists, otherwise prepend
                if grep -q "^## \[未发布\]" "${ZH_TARGET}"; then
                  # Replace existing [未发布] section
                  # Remove everything from "## [未发布]" to the next "## [" (exclusive)
                  awk '
                    BEGIN { in_unreleased = 0 }
                    /^## \[未发布\]/ { in_unreleased = 1; next }
                    in_unreleased && /^## \[/ { in_unreleased = 0 }
                    !in_unreleased { print }
                  ' "${ZH_TARGET}" > /tmp/changelog_zh_temp.md
                  # Prepend new [未发布] content
                  cat /tmp/changelog_zh.md > "${ZH_TARGET}"
                  echo "" >> "${ZH_TARGET}"
                  cat /tmp/changelog_zh_temp.md >> "${ZH_TARGET}"
                else
                  # Prepend [未发布] section
                  cat /tmp/changelog_zh.md > /tmp/changelog_zh_new.md
                  echo "" >> /tmp/changelog_zh_new.md
                  cat "${ZH_TARGET}" >> /tmp/changelog_zh_new.md
                  mv /tmp/changelog_zh_new.md "${ZH_TARGET}"
                fi
              else
                # Create new file
                cat /tmp/changelog_zh.md > "${ZH_TARGET}"
              fi
              echo "✓ Synced Chinese [未发布] changelog to ${ZH_TARGET}"
            fi
          else
            # For version releases, append new version entry
            # Append English changelog (only if it has content)
            if [ -s /tmp/changelog_en.md ] && [ "$(cat /tmp/changelog_en.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              # Check if version already exists in the file
              if [ -f "${EN_TARGET}" ] && grep -q "\[${VERSION_NUMBER}\]" "${EN_TARGET}"; then
                echo "⚠ Version ${VERSION_NUMBER} already exists in ${EN_TARGET}, replacing it"
                # Remove existing version entry
                awk -v version="${VERSION_NUMBER}" '
                  BEGIN { skip = 0 }
                  /^## \[/ {
                    if ($0 ~ "\\[" version "\\]") {
                      skip = 1
                      next
                    } else if (skip && /^## \[/) {
                      skip = 0
                    }
                  }
                  !skip { print }
                ' "${EN_TARGET}" > /tmp/changelog_en_temp.md
                mv /tmp/changelog_en_temp.md "${EN_TARGET}"
              fi
              # Insert new version entry at the beginning
              if [ -f "${EN_TARGET}" ]; then
                # Find the first ## header and insert before it
                if grep -q "^## \[" "${EN_TARGET}"; then
                  # Create temporary file with new content + existing content
                  cat /tmp/changelog_en.md > /tmp/changelog_en_new.md
                  echo "" >> /tmp/changelog_en_new.md
                  cat "${EN_TARGET}" >> /tmp/changelog_en_new.md
                  mv /tmp/changelog_en_new.md "${EN_TARGET}"
                else
                  # Append to end if no version entries found
                  echo "" >> "${EN_TARGET}"
                  cat /tmp/changelog_en.md >> "${EN_TARGET}"
                fi
              else
                # Create new file
                cat /tmp/changelog_en.md > "${EN_TARGET}"
              fi
              echo "✓ Synced English changelog to ${EN_TARGET}"
            fi

            # Append Chinese changelog (only if it has content)
            if [ -s /tmp/changelog_zh.md ] && [ "$(cat /tmp/changelog_zh.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              # Check if version already exists in the file
              if [ -f "${ZH_TARGET}" ] && grep -q "\[${VERSION_NUMBER}\]" "${ZH_TARGET}"; then
                echo "⚠ Version ${VERSION_NUMBER} already exists in ${ZH_TARGET}, replacing it"
                # Remove existing version entry
                awk -v version="${VERSION_NUMBER}" '
                  BEGIN { skip = 0 }
                  /^## \[/ {
                    if ($0 ~ "\\[" version "\\]") {
                      skip = 1
                      next
                    } else if (skip && /^## \[/) {
                      skip = 0
                    }
                  }
                  !skip { print }
                ' "${ZH_TARGET}" > /tmp/changelog_zh_temp.md
                mv /tmp/changelog_zh_temp.md "${ZH_TARGET}"
              fi
              # Insert new version entry at the beginning
              if [ -f "${ZH_TARGET}" ]; then
                # Find the first ## header and insert before it
                if grep -q "^## \[" "${ZH_TARGET}"; then
                  # Create temporary file with new content + existing content
                  cat /tmp/changelog_zh.md > /tmp/changelog_zh_new.md
                  echo "" >> /tmp/changelog_zh_new.md
                  cat "${ZH_TARGET}" >> /tmp/changelog_zh_new.md
                  mv /tmp/changelog_zh_new.md "${ZH_TARGET}"
                else
                  # Append to end if no version entries found
                  echo "" >> "${ZH_TARGET}"
                  cat /tmp/changelog_zh.md >> "${ZH_TARGET}"
                fi
              else
                # Create new file
                cat /tmp/changelog_zh.md > "${ZH_TARGET}"
              fi
              echo "✓ Synced Chinese changelog to ${ZH_TARGET}"
            fi
          fi

          # Commit and push
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            REPO_NAME="${{ inputs.docs_repo || github.event.inputs.docs_repo || secrets.DOCS_REPOSITORY || 'tegojs/docs' }}"

            # Create branch name
            if [ "$IS_UNRELEASED" == "true" ]; then
              BRANCH_NAME="chore/sync-unreleased-changelog-$(date +%Y%m%d-%H%M%S)"
              COMMIT_MSG="docs(changelog): sync [Unreleased] section"
              PR_TITLE="docs(changelog): sync [Unreleased] section"
              PR_BODY="Automatically sync [Unreleased] changelog from tego-standard repository."
            else
              BRANCH_NAME="chore/sync-changelog-${VERSION_NUMBER}"
              COMMIT_MSG="docs(changelog): sync changelog for ${VERSION}"
              PR_TITLE="docs(changelog): sync changelog for ${VERSION}"
              PR_BODY="Automatically sync changelog for version ${VERSION} from tego-standard repository."
            fi

            # Create and checkout new branch
            git checkout -b "${BRANCH_NAME}"
            git commit -m "${COMMIT_MSG}"

            # Configure git remote with token for push
            # Use x-access-token prefix for GitHub tokens (required for GitHub Actions)
            git remote set-url origin "https://x-access-token:${DOCS_REPO_TOKEN}@github.com/${REPO_NAME}.git"

            # Push branch
            if git push origin "${BRANCH_NAME}"; then
              echo "✓ Pushed branch ${BRANCH_NAME} to docs repository"

              # Create Pull Request using GitHub API
              PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${REPO_NAME}/pulls" \
                -d "{
                  \"title\": \"${PR_TITLE}\",
                  \"body\": \"${PR_BODY}\",
                  \"head\": \"${BRANCH_NAME}\",
                  \"base\": \"main\"
                }")

              HTTP_CODE=$(echo "${PR_RESPONSE}" | tail -n1)
              PR_BODY=$(echo "${PR_RESPONSE}" | sed '$d')

              if [ "${HTTP_CODE}" == "201" ]; then
                PR_URL=$(echo "${PR_BODY}" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
                PR_NUMBER=$(echo "${PR_BODY}" | grep -o '"number":[0-9]*' | head -1 | cut -d':' -f2)
                echo "✓ Created Pull Request: ${PR_URL}"
                echo "PR_NUMBER=${PR_NUMBER}" >> $GITHUB_OUTPUT
                echo "PR_URL=${PR_URL}" >> $GITHUB_OUTPUT

                # Add labels for auto-merge: automated, documentation, sync
                # These labels are required for the docs repository's auto-merge rules
                # First, ensure labels exist (create if they don't)
                LABELS=("automated" "documentation" "sync")
                LABEL_COLORS=("1d76db" "0e8a16" "fbca04")  # Blue, Green, Yellow

                for i in "${!LABELS[@]}"; do
                  LABEL_NAME="${LABELS[$i]}"
                  LABEL_COLOR="${LABEL_COLORS[$i]}"

                  # Check if label exists
                  LABEL_CHECK=$(curl -s -o /dev/null -w "%{http_code}" \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "https://api.github.com/repos/${REPO_NAME}/labels/${LABEL_NAME}")

                  # Create label if it doesn't exist (404)
                  if [ "${LABEL_CHECK}" == "404" ]; then
                    CREATE_LABEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                      -H "Accept: application/vnd.github+json" \
                      -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      "https://api.github.com/repos/${REPO_NAME}/labels" \
                      -d "{\"name\":\"${LABEL_NAME}\",\"color\":\"${LABEL_COLOR}\",\"description\":\"Auto-merge label for ${LABEL_NAME} PRs\"}")

                    CREATE_LABEL_HTTP_CODE=$(echo "${CREATE_LABEL_RESPONSE}" | tail -n1)
                    if [ "${CREATE_LABEL_HTTP_CODE}" == "201" ]; then
                      echo "✓ Created label: ${LABEL_NAME}"
                    elif [ "${CREATE_LABEL_HTTP_CODE}" == "422" ]; then
                      echo "⚠ Label ${LABEL_NAME} might already exist (422)"
                    else
                      echo "⚠ Failed to create label ${LABEL_NAME} (HTTP ${CREATE_LABEL_HTTP_CODE})"
                    fi
                  fi
                done

                # Add labels to the PR one by one (more reliable than batch)
                ADDED_LABELS=()
                for LABEL_NAME in "${LABELS[@]}"; do
                  echo "Adding label: ${LABEL_NAME}..."
                  SINGLE_LABEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "https://api.github.com/repos/${REPO_NAME}/issues/${PR_NUMBER}/labels" \
                    -d "[\"${LABEL_NAME}\"]")

                  SINGLE_LABEL_HTTP_CODE=$(echo "${SINGLE_LABEL_RESPONSE}" | tail -n1)
                  SINGLE_LABEL_BODY=$(echo "${SINGLE_LABEL_RESPONSE}" | sed '$d')

                  if [ "${SINGLE_LABEL_HTTP_CODE}" == "200" ] || [ "${SINGLE_LABEL_HTTP_CODE}" == "201" ]; then
                    echo "✓ Added label: ${LABEL_NAME}"
                    ADDED_LABELS+=("${LABEL_NAME}")
                  else
                    echo "⚠ Failed to add label ${LABEL_NAME} (HTTP ${SINGLE_LABEL_HTTP_CODE})"
                    echo "Response: ${SINGLE_LABEL_BODY}"
                  fi

                  # Small delay to avoid rate limiting
                  sleep 0.5
                done

                # Verify labels were added by fetching PR labels
                echo "Verifying labels were added..."
                sleep 1  # Wait for GitHub to update

                VERIFY_LABELS_RESPONSE=$(curl -s \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "https://api.github.com/repos/${REPO_NAME}/issues/${PR_NUMBER}/labels")

                VERIFY_LABELS=$(echo "${VERIFY_LABELS_RESPONSE}" | jq -r '.[].name' 2>/dev/null || echo "")

                if [ -n "${VERIFY_LABELS}" ]; then
                  echo "Current PR labels: $(echo "${VERIFY_LABELS}" | tr '\n' ' ')"

                  # Check if all required labels are present
                  HAS_AUTOMATED=false
                  HAS_DOCUMENTATION=false
                  HAS_SYNC=false

                  if echo "${VERIFY_LABELS}" | grep -q "^automated$"; then
                    HAS_AUTOMATED=true
                  fi
                  if echo "${VERIFY_LABELS}" | grep -q "^documentation$"; then
                    HAS_DOCUMENTATION=true
                  fi
                  if echo "${VERIFY_LABELS}" | grep -q "^sync$"; then
                    HAS_SYNC=true
                  fi

                  if [ "${HAS_AUTOMATED}" == "true" ] && [ "${HAS_DOCUMENTATION}" == "true" ] && [ "${HAS_SYNC}" == "true" ]; then
                    echo "✅ All required labels verified: automated, documentation, sync"
                  else
                    echo "⚠ Some labels missing:"
                    echo "  - automated: ${HAS_AUTOMATED}"
                    echo "  - documentation: ${HAS_DOCUMENTATION}"
                    echo "  - sync: ${HAS_SYNC}"
                    echo "Attempting to re-add missing labels..."

                    # Retry adding missing labels
                    if [ "${HAS_AUTOMATED}" != "true" ]; then
                      curl -s -X POST \
                        -H "Accept: application/vnd.github+json" \
                        -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                        -H "X-GitHub-Api-Version: 2022-11-28" \
                        "https://api.github.com/repos/${REPO_NAME}/issues/${PR_NUMBER}/labels" \
                        -d '["automated"]' > /dev/null && echo "✓ Re-added label: automated"
                    fi
                    if [ "${HAS_DOCUMENTATION}" != "true" ]; then
                      curl -s -X POST \
                        -H "Accept: application/vnd.github+json" \
                        -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                        -H "X-GitHub-Api-Version: 2022-11-28" \
                        "https://api.github.com/repos/${REPO_NAME}/issues/${PR_NUMBER}/labels" \
                        -d '["documentation"]' > /dev/null && echo "✓ Re-added label: documentation"
                    fi
                    if [ "${HAS_SYNC}" != "true" ]; then
                      curl -s -X POST \
                        -H "Accept: application/vnd.github+json" \
                        -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                        -H "X-GitHub-Api-Version: 2022-11-28" \
                        "https://api.github.com/repos/${REPO_NAME}/issues/${PR_NUMBER}/labels" \
                        -d '["sync"]' > /dev/null && echo "✓ Re-added label: sync"
                    fi
                  fi
                else
                  echo "⚠ Could not verify labels (jq not available or API error)"
                  echo "Response: ${VERIFY_LABELS_RESPONSE}"
                fi

                # Note: Auto-merge will be triggered automatically by the docs repository's rules
                # if the PR meets the conditions:
                # - Non-draft PR (default)
                # - Branch name starts with "chore/sync-" (already satisfied)
                # - Has labels: automated, documentation, sync (just added above)
              elif [ "${HTTP_CODE}" == "422" ]; then
                # PR might already exist, try to find it
                echo "⚠ Pull request might already exist, checking..."
                REPO_OWNER=$(echo "${REPO_NAME}" | cut -d'/' -f1)
                REPO_REPO=$(echo "${REPO_NAME}" | cut -d'/' -f2)
                EXISTING_PR=$(curl -s \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "https://api.github.com/repos/${REPO_NAME}/pulls?head=${REPO_OWNER}:${BRANCH_NAME}&state=open")

                EXISTING_PR_URL=$(echo "${EXISTING_PR}" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
                if [ -n "${EXISTING_PR_URL}" ]; then
                  echo "✓ Found existing Pull Request: ${EXISTING_PR_URL}"
                else
                  echo "⚠ Failed to create Pull Request (HTTP ${HTTP_CODE})"
                  echo "Response: ${PR_BODY}"
                fi
              else
                echo "⚠ Failed to create Pull Request (HTTP ${HTTP_CODE})"
                echo "Response: ${PR_BODY}"
                echo "You may need to create the PR manually at: https://github.com/${REPO_NAME}/compare/main...${BRANCH_NAME}"
              fi
            else
              echo "❌ Failed to push branch to docs repository"
              echo ""
              echo "Error: Permission denied (403). This usually means:"
              echo "  1. DOCS_REPO_TOKEN secret is not configured, or"
              echo "  2. GITHUB_TOKEN is being used (cannot push to cross-repository), or"
              echo "  3. Token does not have write permission to ${REPO_NAME}"
              echo ""
              echo "Solution: Configure DOCS_REPO_TOKEN secret:"
              echo "  1. Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
              echo "  2. Click 'New repository secret'"
              echo "  3. Name: DOCS_REPO_TOKEN"
              echo "  4. Value: A Personal Access Token (PAT) with 'repo' scope"
              echo "     - Create PAT at: https://github.com/settings/tokens"
              echo "     - Required scopes: repo (full control of private repositories)"
              echo "     - Must have write access to ${REPO_NAME}"
              echo ""
              echo "Checking git status:"
              git status
              echo "Checking remote (token masked):"
              git remote -v | sed 's/\(x-access-token:\)[^@]*/\1***/g'
              exit 1
            fi
          fi

      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.extract_changelog.outputs.has_changelog }}" == "true" ]; then
            echo "✓ Changelog synced successfully for ${{ steps.version.outputs.version }}"
          else
            echo "⚠ No changelog entry found for ${{ steps.version.outputs.version }}, skipping sync"
          fi

