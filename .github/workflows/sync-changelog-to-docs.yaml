name: Sync Changelog to Docs Repository

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to sync (e.g., v1.5.1)'
        required: false
        type: string
      docs_repo:
        description: 'Documentation repository (e.g., tegojs/docs)'
        required: false
        type: string
  workflow_call:
    inputs:
      version:
        description: 'Version to sync (e.g., v1.5.1)'
        required: false
        type: string
      docs_repo:
        description: 'Documentation repository (e.g., tegojs/docs)'
        required: false
        type: string
    secrets:
      DOCS_REPOSITORY:
        required: false
      DOCS_REPO_TOKEN:
        required: false
      DOCS_CHANGELOG_EN_PATH:
        required: false
      DOCS_CHANGELOG_ZH_PATH:
        required: false

run-name: "Sync Changelog - Version: ${{ github.ref_name || inputs.version || github.event.inputs.version }}"

jobs:
  sync-changelog:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: source
          # When called as reusable workflow, ensure we checkout the latest commit
          # This is important because the calling workflow may have just committed changes
          ref: ${{ github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch latest changes
        run: |
          cd source
          # Fetch all branches and tags to ensure we have the latest commits
          git fetch --all --tags --force

          # Determine the branch name from github.ref
          # Extract branch name from ref (e.g., refs/heads/main -> main, refs/tags/v1.0.0 -> v1.0.0)
          REF_NAME="${{ github.ref }}"
          if [[ "$REF_NAME" == refs/heads/* ]]; then
            BRANCH_NAME=$(echo "$REF_NAME" | sed 's|refs/heads/||')
          elif [[ "$REF_NAME" == refs/tags/* ]]; then
            # For tags, we don't need to pull, just use the tag
            echo "Checking out tag: $REF_NAME"
            git checkout "$REF_NAME" 2>/dev/null || true
            echo "Current commit: $(git rev-parse HEAD)"
            exit 0
          else
            # Default to main branch if ref format is unexpected
            BRANCH_NAME="main"
          fi

          # Pull latest changes from the branch to ensure we have the most recent commits
          # This is critical when called from update-unreleased-changelog workflow
          # which may have just committed changelog updates
          echo "Checking out and pulling latest changes from branch: $BRANCH_NAME"
          git checkout "$BRANCH_NAME" 2>/dev/null || git checkout -b "$BRANCH_NAME" "origin/$BRANCH_NAME" 2>/dev/null || {
            echo "Warning: Could not checkout branch $BRANCH_NAME, using current HEAD"
          }
          git pull origin "$BRANCH_NAME" 2>/dev/null || echo "Note: Could not pull (may already be up to date)"

          echo "Current commit: $(git rev-parse HEAD)"
          echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ inputs.version || github.event.inputs.version }}" ]; then
            VERSION="${{ inputs.version || github.event.inputs.version }}"
          elif [ -n "${{ github.ref_name }}" ]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION=$(node -p "require('./source/package.json').version")
            VERSION="v${VERSION}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version to sync: ${VERSION}"

      - name: Extract changelog entries
        id: extract_changelog
        run: |
          cd source

          VERSION="${{ steps.version.outputs.version }}"
          VERSION_NUMBER=${VERSION#v}

          # Check if syncing Unreleased section
          if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
            echo "Syncing [Unreleased] section"

            # Extract [Unreleased] section from CHANGELOG.md
            # Note: The source changelog should already be deduplicated by update-unreleased.mjs script
            if [ -f "CHANGELOG.md" ]; then
              awk '
                /^## \[Unreleased\]/ {
                  print_section = 1
                  print $0
                  next
                }
                print_section {
                  if (/^## \[/) {
                    exit
                  }
                  print
                }
              ' CHANGELOG.md > /tmp/changelog_en.md || echo "" > /tmp/changelog_en.md
            else
              echo "" > /tmp/changelog_en.md
            fi

            # Extract [未发布] section from CHANGELOG.zh-CN.md
            # Note: The source changelog should already be deduplicated by update-unreleased.mjs script
            if [ -f "CHANGELOG.zh-CN.md" ]; then
              awk '
                /^## \[未发布\]/ {
                  print_section = 1
                  print $0
                  next
                }
                print_section {
                  if (/^## \[/) {
                    exit
                  }
                  print
                }
              ' CHANGELOG.zh-CN.md > /tmp/changelog_zh.md || echo "" > /tmp/changelog_zh.md
            else
              echo "" > /tmp/changelog_zh.md
            fi
          else
            # Extract changelog entry for this version from CHANGELOG.md
            if [ -f "CHANGELOG.md" ]; then
              awk -v version="$VERSION_NUMBER" '
                /^## \[/ {
                  if ($0 ~ "\\[" version "\\]") {
                    print_section = 1
                    print $0
                    next
                  } else if (print_section && /^## \[/) {
                    exit
                  }
                }
                print_section { print }
              ' CHANGELOG.md > /tmp/changelog_en.md || echo "" > /tmp/changelog_en.md
            else
              echo "" > /tmp/changelog_en.md
            fi

            # Extract changelog entry for this version from CHANGELOG.zh-CN.md
            if [ -f "CHANGELOG.zh-CN.md" ]; then
              awk -v version="$VERSION_NUMBER" '
                /^## \[/ {
                  if ($0 ~ "\\[" version "\\]") {
                    print_section = 1
                    print $0
                    next
                  } else if (print_section && /^## \[/) {
                    exit
                  }
                }
                print_section { print }
              ' CHANGELOG.zh-CN.md > /tmp/changelog_zh.md || echo "" > /tmp/changelog_zh.md
            else
              echo "" > /tmp/changelog_zh.md
            fi
          fi

          # Check if changelog entries exist (more than just empty lines)
          EN_LINES=$(cat /tmp/changelog_en.md | grep -v '^[[:space:]]*$' | wc -l)
          ZH_LINES=$(cat /tmp/changelog_zh.md | grep -v '^[[:space:]]*$' | wc -l)

          # Log detailed information
          echo "Changelog extraction results:"
          echo "  English: $EN_LINES lines (file: /tmp/changelog_en.md)"
          echo "  Chinese: $ZH_LINES lines (file: /tmp/changelog_zh.md)"

          if [ "$EN_LINES" -gt 1 ]; then
            echo "✓ English changelog has content"
          else
            echo "⚠ English changelog is empty or has no content"
          fi

          if [ "$ZH_LINES" -gt 1 ]; then
            echo "✓ Chinese changelog has content"
          else
            echo "⚠ Chinese changelog is empty or has no content"
            if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
              echo "  This may be because:"
              echo "    1. Translation failed during update-unreleased step"
              echo "    2. No Chinese content was generated"
              echo "    3. CHANGELOG.zh-CN.md was not updated in the previous step"
            fi
          fi

          if [ "$EN_LINES" -gt 1 ] || [ "$ZH_LINES" -gt 1 ]; then
            echo "has_changelog=true" >> $GITHUB_OUTPUT
            echo "Found changelog entries: EN($EN_LINES lines), ZH($ZH_LINES lines)"
          else
            echo "has_changelog=false" >> $GITHUB_OUTPUT
            if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
              echo "No [Unreleased] entries found"
            else
              echo "No changelog entries found for version $VERSION_NUMBER"
            fi
          fi

      - name: Checkout docs repository
        if: steps.extract_changelog.outputs.has_changelog == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.docs_repo || github.event.inputs.docs_repo || secrets.DOCS_REPOSITORY || 'tegojs/docs' }}
          # Note: GITHUB_TOKEN cannot access cross-repository, must use DOCS_REPO_TOKEN (PAT)
          token: ${{ secrets.DOCS_REPO_TOKEN || secrets.GITHUB_TOKEN }}
          path: docs
          fetch-depth: 1
          ref: main

      - name: Setup Git
        if: steps.extract_changelog.outputs.has_changelog == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Sync changelog to docs repository
        if: steps.extract_changelog.outputs.has_changelog == 'true'
        env:
          DOCS_CHANGELOG_EN_PATH: ${{ secrets.DOCS_CHANGELOG_EN_PATH || 'docs/en/changelog/changelog.md' }}
          DOCS_CHANGELOG_ZH_PATH: ${{ secrets.DOCS_CHANGELOG_ZH_PATH || 'docs/zh/changelog/changelog.md' }}
          DOCS_REPO_TOKEN: ${{ secrets.DOCS_REPO_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          cd docs

          VERSION="${{ steps.version.outputs.version }}"
          VERSION_NUMBER=${VERSION#v}
          IS_UNRELEASED=false

          if [ "$VERSION" == "unreleased" ] || [ "$VERSION_NUMBER" == "unreleased" ]; then
            IS_UNRELEASED=true
          fi

          # Determine target file paths
          EN_TARGET="${DOCS_CHANGELOG_EN_PATH}"
          ZH_TARGET="${DOCS_CHANGELOG_ZH_PATH}"

          # Create directories if they don't exist
          mkdir -p "$(dirname "${EN_TARGET}")"
          mkdir -p "$(dirname "${ZH_TARGET}")"

          if [ "$IS_UNRELEASED" == "true" ]; then
            # For Unreleased section, replace the entire section
            # Note: Content is already deduplicated and properly formatted by update-unreleased.mjs script
            # The extracted section includes the "## [Unreleased]" header

            # Helper function to replace [Unreleased] section in target file
            # Usage: replace_unreleased_section <target_file> <section_header> <new_content_file>
            replace_unreleased_section() {
              local target_file="$1"
              local section_header="$2"
              local new_content_file="$3"

              if [ -f "${target_file}" ]; then
                # Remove existing section if exists, then prepend new content
                if grep -q "^## \[${section_header}\]" "${target_file}"; then
                  # Remove the section (from "## [header]" to next "## [" or end of file)
                  awk -v header="${section_header}" '
                    BEGIN { in_section = 0 }
                    /^## \[/ && $0 ~ "\\[" header "\\]" { in_section = 1; next }
                    in_section && /^## \[/ { in_section = 0 }
                    !in_section { print }
                  ' "${target_file}" > /tmp/temp_changelog.md
                  cat "${new_content_file}" > "${target_file}"
                  echo "" >> "${target_file}"
                  cat /tmp/temp_changelog.md >> "${target_file}"
                else
                  # No section found, prepend new content
                  cat "${new_content_file}" > /tmp/temp_changelog.md
                  echo "" >> /tmp/temp_changelog.md
                  cat "${target_file}" >> /tmp/temp_changelog.md
                  mv /tmp/temp_changelog.md "${target_file}"
                fi
              else
                # Create new file
                cat "${new_content_file}" > "${target_file}"
              fi
            }

            # Sync English changelog (only if it has content)
            if [ -s /tmp/changelog_en.md ] && [ "$(cat /tmp/changelog_en.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              replace_unreleased_section "${EN_TARGET}" "Unreleased" /tmp/changelog_en.md
              echo "✓ Synced English [Unreleased] changelog to ${EN_TARGET}"
            else
              echo "⚠ Skipped syncing English changelog (no content or empty file)"
            fi

            # Sync Chinese changelog (only if it has content)
            if [ -s /tmp/changelog_zh.md ] && [ "$(cat /tmp/changelog_zh.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              replace_unreleased_section "${ZH_TARGET}" "未发布" /tmp/changelog_zh.md
              echo "✓ Synced Chinese [未发布] changelog to ${ZH_TARGET}"
            else
              echo "⚠ Skipped syncing Chinese changelog (no content or empty file)"
              echo "  This may be because translation failed or Chinese content was not generated in the update step"
            fi
          else
            # For version releases, append new version entry
            # Append English changelog (only if it has content)
            if [ -s /tmp/changelog_en.md ] && [ "$(cat /tmp/changelog_en.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              # Check if version already exists in the file
              if [ -f "${EN_TARGET}" ] && grep -q "\[${VERSION_NUMBER}\]" "${EN_TARGET}"; then
                echo "⚠ Version ${VERSION_NUMBER} already exists in ${EN_TARGET}, replacing it"
                # Remove existing version entry
                awk -v version="${VERSION_NUMBER}" '
                  BEGIN { skip = 0 }
                  /^## \[/ {
                    if ($0 ~ "\\[" version "\\]") {
                      skip = 1
                      next
                    } else if (skip && /^## \[/) {
                      skip = 0
                    }
                  }
                  !skip { print }
                ' "${EN_TARGET}" > /tmp/changelog_en_temp.md
                mv /tmp/changelog_en_temp.md "${EN_TARGET}"
              fi
              # Insert new version entry at the beginning
              if [ -f "${EN_TARGET}" ]; then
                # Find the first ## header and insert before it
                if grep -q "^## \[" "${EN_TARGET}"; then
                  # Create temporary file with new content + existing content
                  cat /tmp/changelog_en.md > /tmp/changelog_en_new.md
                  echo "" >> /tmp/changelog_en_new.md
                  cat "${EN_TARGET}" >> /tmp/changelog_en_new.md
                  mv /tmp/changelog_en_new.md "${EN_TARGET}"
                else
                  # Append to end if no version entries found
                  echo "" >> "${EN_TARGET}"
                  cat /tmp/changelog_en.md >> "${EN_TARGET}"
                fi
              else
                # Create new file
                cat /tmp/changelog_en.md > "${EN_TARGET}"
              fi
              echo "✓ Synced English changelog to ${EN_TARGET}"
            else
              echo "⚠ Skipped syncing English changelog (no content or empty file)"
            fi

            # Append Chinese changelog (only if it has content)
            if [ -s /tmp/changelog_zh.md ] && [ "$(cat /tmp/changelog_zh.md | grep -v '^[[:space:]]*$' | wc -l)" -gt 1 ]; then
              # Check if version already exists in the file
              if [ -f "${ZH_TARGET}" ] && grep -q "\[${VERSION_NUMBER}\]" "${ZH_TARGET}"; then
                echo "⚠ Version ${VERSION_NUMBER} already exists in ${ZH_TARGET}, replacing it"
                # Remove existing version entry
                awk -v version="${VERSION_NUMBER}" '
                  BEGIN { skip = 0 }
                  /^## \[/ {
                    if ($0 ~ "\\[" version "\\]") {
                      skip = 1
                      next
                    } else if (skip && /^## \[/) {
                      skip = 0
                    }
                  }
                  !skip { print }
                ' "${ZH_TARGET}" > /tmp/changelog_zh_temp.md
                mv /tmp/changelog_zh_temp.md "${ZH_TARGET}"
              fi
              # Insert new version entry at the beginning
              if [ -f "${ZH_TARGET}" ]; then
                # Find the first ## header and insert before it
                if grep -q "^## \[" "${ZH_TARGET}"; then
                  # Create temporary file with new content + existing content
                  cat /tmp/changelog_zh.md > /tmp/changelog_zh_new.md
                  echo "" >> /tmp/changelog_zh_new.md
                  cat "${ZH_TARGET}" >> /tmp/changelog_zh_new.md
                  mv /tmp/changelog_zh_new.md "${ZH_TARGET}"
                else
                  # Append to end if no version entries found
                  echo "" >> "${ZH_TARGET}"
                  cat /tmp/changelog_zh.md >> "${ZH_TARGET}"
                fi
              else
                # Create new file
                cat /tmp/changelog_zh.md > "${ZH_TARGET}"
              fi
              echo "✓ Synced Chinese changelog to ${ZH_TARGET}"
            else
              echo "⚠ Skipped syncing Chinese changelog (no content or empty file)"
              echo "  This may be because translation failed or Chinese content was not generated"
            fi
          fi

          # Commit and push
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            REPO_NAME="${{ inputs.docs_repo || github.event.inputs.docs_repo || secrets.DOCS_REPOSITORY || 'tegojs/docs' }}"

            # Create branch name
            if [ "$IS_UNRELEASED" == "true" ]; then
              BRANCH_NAME="chore/sync-unreleased-changelog-$(date +%Y%m%d-%H%M%S)"
              COMMIT_MSG="docs(changelog): sync [Unreleased] section"
              PR_TITLE="docs(changelog): sync [Unreleased] section"
              PR_BODY="Automatically sync [Unreleased] changelog from tego-standard repository."
            else
              BRANCH_NAME="chore/sync-changelog-${VERSION_NUMBER}"
              COMMIT_MSG="docs(changelog): sync changelog for ${VERSION}"
              PR_TITLE="docs(changelog): sync changelog for ${VERSION}"
              PR_BODY="Automatically sync changelog for version ${VERSION} from tego-standard repository."
            fi

            # Create and checkout new branch
            git checkout -b "${BRANCH_NAME}"
            git commit -m "${COMMIT_MSG}"

            # Configure git remote with token for push
            # Use x-access-token prefix for GitHub tokens (required for GitHub Actions)
            git remote set-url origin "https://x-access-token:${DOCS_REPO_TOKEN}@github.com/${REPO_NAME}.git"

            # Push branch
            if git push origin "${BRANCH_NAME}"; then
              echo "✓ Pushed branch ${BRANCH_NAME} to docs repository"

              # Create Pull Request using GitHub API
              PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${REPO_NAME}/pulls" \
                -d "{
                  \"title\": \"${PR_TITLE}\",
                  \"body\": \"${PR_BODY}\",
                  \"head\": \"${BRANCH_NAME}\",
                  \"base\": \"main\"
                }")

              HTTP_CODE=$(echo "${PR_RESPONSE}" | tail -n1)
              PR_BODY=$(echo "${PR_RESPONSE}" | sed '$d')

              if [ "${HTTP_CODE}" == "201" ]; then
                # Extract PR number and URL
                if command -v jq >/dev/null 2>&1; then
                  PR_NUMBER=$(echo "${PR_BODY}" | jq -r '.number // empty')
                  PR_URL=$(echo "${PR_BODY}" | jq -r '.html_url // empty')
                else
                  PR_NUMBER=$(echo "${PR_BODY}" | grep -o '"number":[0-9]*' | head -1 | cut -d':' -f2)
                  PR_URL=$(echo "${PR_BODY}" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
                fi

                if [ -z "${PR_NUMBER}" ] || [ "${PR_NUMBER}" == "null" ]; then
                  echo "❌ Failed to extract PR number"
                  exit 1
                fi

                if [ -z "${PR_URL}" ] || [ "${PR_URL}" == "null" ]; then
                  PR_URL="https://github.com/${REPO_NAME}/pull/${PR_NUMBER}"
                fi

                echo "✓ Created Pull Request #${PR_NUMBER}: ${PR_URL}"
                echo "PR_NUMBER=${PR_NUMBER}" >> $GITHUB_OUTPUT
                echo "PR_URL=${PR_URL}" >> $GITHUB_OUTPUT

                # Add labels for auto-merge: automated, documentation, sync
                # These labels are required for the docs repository's auto-merge rules
                # First, ensure labels exist (create if they don't)
                LABELS=("automated" "documentation" "sync")
                LABEL_COLORS=("1d76db" "0e8a16" "fbca04")  # Blue, Green, Yellow

                for i in "${!LABELS[@]}"; do
                  LABEL_NAME="${LABELS[$i]}"
                  LABEL_COLOR="${LABEL_COLORS[$i]}"

                  # Check if label exists
                  LABEL_CHECK=$(curl -s -o /dev/null -w "%{http_code}" \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "https://api.github.com/repos/${REPO_NAME}/labels/${LABEL_NAME}")

                  # Create label if it doesn't exist (404)
                  if [ "${LABEL_CHECK}" == "404" ]; then
                    CREATE_LABEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                      -H "Accept: application/vnd.github+json" \
                      -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      "https://api.github.com/repos/${REPO_NAME}/labels" \
                      -d "{\"name\":\"${LABEL_NAME}\",\"color\":\"${LABEL_COLOR}\",\"description\":\"Auto-merge label for ${LABEL_NAME} PRs\"}")

                    CREATE_LABEL_HTTP_CODE=$(echo "${CREATE_LABEL_RESPONSE}" | tail -n1)
                    if [ "${CREATE_LABEL_HTTP_CODE}" == "201" ]; then
                      echo "✓ Created label: ${LABEL_NAME}"
                    fi
                  fi
                done

                # Add labels to the PR
                for LABEL_NAME in "${LABELS[@]}"; do
                  curl -s -X POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    -H "Content-Type: application/json" \
                    "https://api.github.com/repos/${REPO_NAME}/issues/${PR_NUMBER}/labels" \
                    -d "[\"${LABEL_NAME}\"]" > /dev/null
                  sleep 0.3
                done
                echo "✓ Added labels: ${LABELS[*]}"
              elif [ "${HTTP_CODE}" == "422" ]; then
                # PR might already exist
                REPO_OWNER=$(echo "${REPO_NAME}" | cut -d'/' -f1)
                EXISTING_PR=$(curl -s \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer ${DOCS_REPO_TOKEN}" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "https://api.github.com/repos/${REPO_NAME}/pulls?head=${REPO_OWNER}:${BRANCH_NAME}&state=open")
                EXISTING_PR_URL=$(echo "${EXISTING_PR}" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
                if [ -n "${EXISTING_PR_URL}" ]; then
                  echo "✓ Found existing Pull Request: ${EXISTING_PR_URL}"
                else
                  echo "⚠ Failed to create Pull Request (HTTP ${HTTP_CODE})"
                fi
              else
                echo "⚠ Failed to create Pull Request (HTTP ${HTTP_CODE})"
              fi
            else
              echo "❌ Failed to push branch to docs repository"
              echo ""
              echo "Error: Permission denied (403). This usually means:"
              echo "  1. DOCS_REPO_TOKEN secret is not configured, or"
              echo "  2. GITHUB_TOKEN is being used (cannot push to cross-repository), or"
              echo "  3. Token does not have write permission to ${REPO_NAME}"
              echo ""
              echo "Solution: Configure DOCS_REPO_TOKEN secret:"
              echo "  1. Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
              echo "  2. Click 'New repository secret'"
              echo "  3. Name: DOCS_REPO_TOKEN"
              echo "  4. Value: A Personal Access Token (PAT) with 'repo' scope"
              echo "     - Create PAT at: https://github.com/settings/tokens"
              echo "     - Required scopes: repo (full control of private repositories)"
              echo "     - Must have write access to ${REPO_NAME}"
              echo ""
              echo "Checking git status:"
              git status
              echo "Checking remote (token masked):"
              git remote -v | sed 's/\(x-access-token:\)[^@]*/\1***/g'
              exit 1
            fi
          fi

      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.extract_changelog.outputs.has_changelog }}" == "true" ]; then
            echo "✓ Changelog synced successfully for ${{ steps.version.outputs.version }}"
          else
            echo "⚠ No changelog entry found for ${{ steps.version.outputs.version }}, skipping sync"
          fi

