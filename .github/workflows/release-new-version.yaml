name: Release New Version

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      from_alpha:
        description: 'Release from alpha version (based on latest tested alpha)'
        required: false
        default: false
        type: boolean

run-name: "Release New Version - Bump: ${{ github.event.inputs.bump || 'patch' }}${{ github.event.inputs.from_alpha == 'true' && ' (from alpha)' || '' }}"

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
      actions: write
    outputs:
      version: ${{ steps.do_version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}
          fetch-depth: 0  # 获取完整的 git 历史，包括所有 tags
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.18.0
      - name: Fetch all tags
        run: |
          # 确保获取所有远程 tags，用于版本比较
          git fetch --tags --force
          echo "Available tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"
      - name: Do version release
        id: do_version
        run: |
          # 读取当前版本号
          current_version=$(node -p "require('./package.json').version")
          echo "Current version: $current_version"

          # 检查是否基于 alpha 版本发布
          from_alpha="${{ github.event.inputs.from_alpha }}"
          echo "Release from alpha: $from_alpha"

          if [ "$from_alpha" = "true" ]; then
            echo "=== Releasing from alpha version ==="

            # 查找最新的 alpha 版本 tag
            latest_alpha_tag=$(git tag --sort=-version:refname | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+-alpha\.[0-9]+$" | head -1 || echo "")

            if [ -z "$latest_alpha_tag" ]; then
              echo "❌ Error: No alpha version tag found. Please create an alpha version first."
              echo "Available tags:"
              git tag --sort=-version:refname | head -10
              exit 1
            fi

            echo "Found latest alpha tag: $latest_alpha_tag"

            # 提取基础版本号（去掉 alpha 后缀）
            base_version=$(echo "$latest_alpha_tag" | sed -E 's/^v([0-9]+\.[0-9]+\.[0-9]+)-alpha\.[0-9]+$/\1/')

            if [ -z "$base_version" ] || [ "$base_version" = "$latest_alpha_tag" ]; then
              echo "❌ Error: Failed to extract base version from alpha tag: $latest_alpha_tag"
              exit 1
            fi

            echo "Base version extracted: $base_version"

            # 检查该基础版本是否已经作为正式版本发布
            # 转义基础版本号中的点号，用于正则表达式匹配
            escaped_base_version=$(echo "$base_version" | sed 's/\./\\./g')
            existing_release_tag=$(git tag --sort=-version:refname | grep -E "^v${escaped_base_version}$" | head -1 || echo "")
            if [ -n "$existing_release_tag" ]; then
              echo "❌ Error: Version $base_version has already been released as $existing_release_tag"
              echo "Please use a different bump type or create a new alpha version first."
              exit 1
            fi

            # 使用基础版本号作为正式版本
            version="$base_version"
            echo "Using base version as release version: $version"

            # 更新所有 package.json 文件到正式版本号
            node -e "
              const fs = require('fs');
              const { execSync } = require('child_process');

              // 更新根目录 package.json
              const rootPkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              rootPkg.version = '$version';
              fs.writeFileSync('package.json', JSON.stringify(rootPkg, null, 2) + '\n');

              // 更新所有子包的 package.json
              const packages = execSync('find . -name package.json -not -path \"*/node_modules/*\" -not -path \"*/dist/*\"', { encoding: 'utf8' })
                .trim()
                .split('\n')
                .filter(p => p !== './package.json');

              packages.forEach(pkgPath => {
                try {
                  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
                  pkg.version = '$version';
                  fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
                } catch (e) {
                  console.error('Error updating', pkgPath, ':', e.message);
                }
              });

              console.log('✓ Updated', packages.length + 1, 'package.json files from alpha to version $version');
            "

            echo "alpha_version=$latest_alpha_tag" >> $GITHUB_OUTPUT
          else
            echo "=== Releasing new version (standard bump) ==="

            # 使用 bump 类型
            bump="${{ github.event.inputs.bump || 'patch' }}"
            echo "Using bump type: $bump"

            if [ "$bump" = "major" ]; then
              if ! pnpm -r exec -- npm version major --no-git-tag-version; then
                echo "❌ Error: Failed to bump version in some packages"
                exit 1
              fi
              version=$(npm version major --no-git-tag-version | sed 's/^v//')
            elif [ "$bump" = "minor" ]; then
              if ! pnpm -r exec -- npm version minor --no-git-tag-version; then
                echo "❌ Error: Failed to bump version in some packages"
                exit 1
              fi
              version=$(npm version minor --no-git-tag-version | sed 's/^v//')
            else
              # patch (default)
              if ! pnpm -r exec -- npm version patch --no-git-tag-version; then
                echo "❌ Error: Failed to bump version in some packages"
                exit 1
              fi
              version=$(npm version patch --no-git-tag-version | sed 's/^v//')
            fi
          fi

          # 验证根目录版本号
          ROOT_VERSION=$(node -p "require('./package.json').version")
          if [ "$ROOT_VERSION" != "$version" ]; then
            echo "❌ Error: Root package.json version mismatch. Expected $version, got $ROOT_VERSION"
            exit 1
          fi

          # 统计所有更新的 package.json 文件
          UPDATED_COUNT=$(git diff --name-only HEAD | grep -c "package.json$" || echo "0")
          echo "✓ Version bumped to: $version ($UPDATED_COUNT package.json files updated)"

          echo "New version: $version"
          # 输出版本号（不带 v 前缀，用于内部处理）
          echo "version=$version" >> $GITHUB_OUTPUT
          # 输出带 v 前缀的版本号（用于创建 tag）
          echo "version_tag=v$version" >> $GITHUB_OUTPUT
          echo "current_version=$current_version" >> $GITHUB_OUTPUT
          echo "::notice title=Version Updated::New version: $version"

      - name: Fetch all tags
        run: |
          # 确保获取所有远程 tags
          git fetch --tags --force
          echo "Available tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"

      - name: Generate changelog
        id: generate_changelog
        run: |
          set -e  # 如果任何命令失败，立即退出

          current_version="${{ steps.do_version.outputs.current_version }}"
          new_version="${{ steps.do_version.outputs.version }}"
          from_alpha="${{ github.event.inputs.from_alpha }}"
          alpha_version="${{ steps.do_version.outputs.alpha_version }}"

          # 如果基于 alpha 版本发布，优先使用 alpha 版本之前的 tag
          if [ "$from_alpha" = "true" ] && [ -n "$alpha_version" ]; then
            echo "=== Generating changelog from alpha version ==="
            echo "Alpha version: $alpha_version"
            echo "Release version: $new_version"

            # 查找 alpha 版本之前的最后一个 tag（这样 changelog 会包含从上一个版本到 alpha 再到正式版本的所有变更）
            # 原因：从 alpha 到正式版本之间不应该有新的 commits（代码是一样的，只是版本号变了）
            # 所以我们需要找到 alpha 之前的 tag，以包含完整的变更历史
            # tag 列表按版本号降序排列，我们需要找到 alpha 版本之前的最后一个 tag
            previous_tag=$(git tag --sort=-version:refname | awk -v alpha="$alpha_version" -v new="v${new_version}" '
              {
                # 如果遇到新版本或 alpha 版本，停止并返回之前保存的 tag
                if ($0 == alpha || $0 == new) {
                  if (last_tag) {
                    print last_tag
                  }
                  exit
                }
                # 保存当前 tag（这是 alpha 之前的 tag）
                last_tag = $0
              }
            ' || echo "")

            # 如果找不到 alpha 之前的 tag，尝试查找任何正式版本（排除 alpha 版本）
            if [ -z "$previous_tag" ]; then
              echo "No tag found before alpha version, looking for any previous release version..."
              previous_tag=$(git tag --sort=-version:refname | grep -vE "-alpha\." | grep -v "^v${new_version}$" | head -1 || echo "")

              if [ -z "$previous_tag" ]; then
                # 如果还是找不到，使用 alpha 版本作为基准（虽然从 alpha 到正式版本之间不应该有新 commits）
                previous_tag="$alpha_version"
                echo "⚠ Warning: No previous release tag found, using alpha version as previous tag: $previous_tag"
                echo "  Note: Changelog may be empty as there should be no commits between alpha and release"
              else
                echo "Found previous release tag: $previous_tag"
              fi
            else
              echo "Found previous tag before alpha: $previous_tag"
            fi
          else
            echo "=== Generating changelog (standard release) ==="
            # 获取上一个 tag（排除当前要发布的版本 tag，如果存在）
            # 按版本号排序，获取最新的 tag
            previous_tag=$(git tag --sort=-version:refname | grep -v "^v${new_version}$" | head -1 || echo "")
          fi

          # 如果还是找不到，尝试使用 git describe（但排除当前版本）
          if [ -z "$previous_tag" ]; then
            previous_tag=$(git describe --tags --abbrev=0 --exclude="v${new_version}" 2>/dev/null || echo "")
          fi

          echo "Generating changelog for version: $new_version"

          # 检查 [Unreleased] 内容是否存在
          HAS_UNRELEASED_EN=$(grep -q "^## \[Unreleased\]" CHANGELOG.md && echo "yes" || echo "no")
          HAS_UNRELEASED_ZH=$(grep -q "^## \[未发布\]" CHANGELOG.zh-CN.md && echo "yes" || echo "no")
          echo "  [Unreleased] content available: EN=$HAS_UNRELEASED_EN, ZH=$HAS_UNRELEASED_ZH"

          CHANGELOG_GENERATED=false

          if [ -n "$previous_tag" ]; then
            echo "  From tag: $previous_tag"
            echo "  To version: v$new_version"

            # 先尝试从 git commits 生成
            echo "  Attempting to generate from git commits..."
            if node scripts/generate-changelog.mjs "$new_version" "$previous_tag" 2>&1; then
              # 检查是否成功生成了版本条目
              if grep -q "## \[$new_version\]" CHANGELOG.md; then
                echo "  ✓ Successfully generated from git commits"
                CHANGELOG_GENERATED=true
              else
                echo "  ⚠ Generated but no version entry found, may have no commits"
              fi
            else
              echo "  ⚠ Failed to generate from git commits"
            fi

            # 如果从 git commits 生成失败或没有内容，使用 [Unreleased] 内容
            if [ "$CHANGELOG_GENERATED" != "true" ]; then
              if [ "$HAS_UNRELEASED_EN" = "yes" ] || [ "$HAS_UNRELEASED_ZH" = "yes" ]; then
                echo "  Using [Unreleased] content to generate changelog..."
                CHANGELOG_USE_UNRELEASED=true node scripts/generate-changelog.mjs "$new_version" "$previous_tag" || {
                  echo "  ❌ Failed to generate changelog from [Unreleased] content"
                  exit 1
                }
                CHANGELOG_GENERATED=true
              else
                echo "  ❌ No [Unreleased] content available and no git commits found"
                exit 1
              fi
            fi
          else
            echo "  No previous tag found"
            echo "  Using [Unreleased] content to generate changelog"
            # 如果没有之前的 tag，使用 [Unreleased] 内容
            CHANGELOG_USE_UNRELEASED=true node scripts/generate-changelog.mjs "$new_version" || {
              echo "  ❌ Failed to generate changelog from [Unreleased] content"
              exit 1
            }
            CHANGELOG_GENERATED=true
          fi

          # 验证生成的文件是否存在且有内容
          if [ ! -f "CHANGELOG.md" ]; then
            echo "❌ Error: CHANGELOG.md was not generated"
            exit 1
          fi

          if [ ! -f "CHANGELOG.zh-CN.md" ]; then
            echo "❌ Error: CHANGELOG.zh-CN.md was not generated"
            exit 1
          fi

          # 检查是否包含新版本的条目
          if ! grep -q "## \[$new_version\]" CHANGELOG.md; then
            echo "❌ Error: CHANGELOG.md does not contain entry for version $new_version"
            echo "First 50 lines of CHANGELOG.md:"
            head -50 CHANGELOG.md
            exit 1
          fi

          if ! grep -q "## \[$new_version\]" CHANGELOG.zh-CN.md; then
            echo "❌ Error: CHANGELOG.zh-CN.md does not contain entry for version $new_version"
            echo "First 50 lines of CHANGELOG.zh-CN.md:"
            head -50 CHANGELOG.zh-CN.md
            exit 1
          fi

          # 检查是否有变更（相对于 HEAD）
          if git diff --quiet HEAD CHANGELOG.md CHANGELOG.zh-CN.md; then
            echo "⚠ Warning: No changes detected in CHANGELOG files"
            echo "This may indicate the changelog was already up to date"
            echo "changelog_updated=false" >> $GITHUB_OUTPUT
          else
            echo "✓ Changelog generated successfully with changes"
            echo "Changes preview:"
            git diff --stat HEAD CHANGELOG.md CHANGELOG.zh-CN.md
            echo "changelog_updated=true" >> $GITHUB_OUTPUT
          fi

      - name: Update workflow run name
        env:
          NEW_NAME: "Release New Version - Bump: ${{ github.event.inputs.bump || 'patch' }}${{ github.event.inputs.from_alpha == 'true' && ' (from alpha)' || '' }} → ${{ steps.do_version.outputs.version }}"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
        run: |
          node -e "
            const https = require('https');
            const newName = process.env.NEW_NAME;
            const token = process.env.GITHUB_TOKEN;
            const repo = process.env.REPOSITORY;
            const runId = process.env.RUN_ID;
            const data = JSON.stringify({ display_title: newName });
            const options = {
              hostname: 'api.github.com',
              path: '/repos/' + repo + '/actions/runs/' + runId,
              method: 'PATCH',
              headers: {
                'Accept': 'application/vnd.github+json',
                'Authorization': 'Bearer ' + token,
                'X-GitHub-Api-Version': '2022-11-28',
                'Content-Type': 'application/json',
                'Content-Length': data.length
              }
            };
            const req = https.request(options, (res) => {
              let body = '';
              res.on('data', (chunk) => { body += chunk; });
              res.on('end', () => {
                if (res.statusCode === 200 || res.statusCode === 204) {
                  console.log('✓ Workflow run name updated successfully');
                } else {
                  console.log('⚠ Failed to update run name (status: ' + res.statusCode + '), but continuing...');
                  console.log('Response:', body);
                }
              });
            });
            req.on('error', (e) => {
              console.log('⚠ Error updating run name:', e.message, ', but continuing...');
            });
            req.write(data);
            req.end();
          "

      - name: Verify files before commit
        run: |
          NEW_VERSION="${{ steps.do_version.outputs.version }}"

          echo "=== Verifying files before commit ==="

          # 验证关键文件是否存在
          if [ ! -f "CHANGELOG.md" ]; then
            echo "❌ Error: CHANGELOG.md does not exist"
            exit 1
          fi
          if [ ! -f "CHANGELOG.zh-CN.md" ]; then
            echo "❌ Error: CHANGELOG.zh-CN.md does not exist"
            exit 1
          fi

          # 检查 CHANGELOG 是否包含新版本条目
          if ! grep -q "## \[$NEW_VERSION\]" CHANGELOG.md; then
            echo "❌ Error: CHANGELOG.md does not contain entry for version $NEW_VERSION"
            echo "Available versions in CHANGELOG.md:"
            grep "^## \[" CHANGELOG.md | head -5
            exit 1
          fi

          if ! grep -q "## \[$NEW_VERSION\]" CHANGELOG.zh-CN.md; then
            echo "❌ Error: CHANGELOG.zh-CN.md does not contain entry for version $NEW_VERSION"
            echo "Available versions in CHANGELOG.zh-CN.md:"
            grep "^## \[" CHANGELOG.zh-CN.md | head -5
            exit 1
          fi

          # 显示文件变更状态
          echo ""
          echo "=== File changes status ==="
          echo "All package.json files changed:"
          git diff --name-only HEAD | grep "package.json$" | head -20 || echo "  (no package.json changes found)"
          TOTAL_PKG_CHANGES=$(git diff --name-only HEAD | grep -c "package.json$" || echo "0")
          echo "Total package.json files changed: $TOTAL_PKG_CHANGES"

          # 验证至少更新了根目录和主要包的 package.json
          # 通常应该有 90+ 个 package.json 文件（根目录 + packages/* + apps/*）
          if [ "$TOTAL_PKG_CHANGES" -lt 10 ]; then
            echo "❌ Error: Expected at least 10+ package.json files to be updated, but only $TOTAL_PKG_CHANGES found"
            echo "This indicates that not all packages were updated correctly"
            echo "Please check if pnpm -r exec command succeeded for all packages"
            exit 1
          fi

          # 验证根目录 package.json 的版本号是否正确（而不是检查是否在 diff 中）
          # 因为版本更新步骤已经更新了它，所以它可能已经在工作区中
          ROOT_PKG_VERSION=$(grep -E '^\s*"version"\s*:\s*"' package.json | head -1 | sed -E 's/.*"version"\s*:\s*"([^"]+)".*/\1/' || echo "")
          if [ -z "$ROOT_PKG_VERSION" ]; then
            echo "⚠ Warning: Could not read root package.json version"
          elif [ "$ROOT_PKG_VERSION" != "$NEW_VERSION" ]; then
            echo "❌ Error: Root package.json version is $ROOT_PKG_VERSION, expected $NEW_VERSION"
            exit 1
          else
            echo "✓ Root package.json version verified: $ROOT_PKG_VERSION"
          fi

          echo ""
          echo "CHANGELOG.md changes:"
          git diff --stat HEAD CHANGELOG.md 2>/dev/null || echo "  (no changes)"

          echo ""
          echo "CHANGELOG.zh-CN.md changes:"
          git diff --stat HEAD CHANGELOG.zh-CN.md 2>/dev/null || echo "  (no changes)"

          # 显示 CHANGELOG 中新版本条目的预览
          echo ""
          echo "=== CHANGELOG.md entry preview for $NEW_VERSION ==="
          grep -A 10 "## \[$NEW_VERSION\]" CHANGELOG.md | head -15

          echo ""
          echo "=== CHANGELOG.zh-CN.md entry preview for $NEW_VERSION ==="
          grep -A 10 "## \[$NEW_VERSION\]" CHANGELOG.zh-CN.md | head -15

          echo ""
          echo "✓ All files verified successfully"

      - name: Stage all changed files
        run: |
          # 显式添加所有需要提交的文件
          echo "Staging all changed files..."

          # 添加根目录 package.json
          if [ -f "package.json" ]; then
            git add package.json
            echo "✓ Added package.json"
          fi

          # 添加所有子目录的 package.json 文件（排除 node_modules 和 dist）
          find . \
            -type d \( -name node_modules -o -name dist \) -prune \
            -o -name package.json -type f -print | \
          while IFS= read -r file; do
            if [ "$file" != "./package.json" ]; then
              git add "$file"
            fi
          done
          echo "✓ Added all package.json files"

          # 添加 CHANGELOG 文件
          git add CHANGELOG.md CHANGELOG.zh-CN.md
          echo "✓ Added CHANGELOG files"

          # 显示将要提交的文件
          echo ""
          echo "Files staged for commit:"
          git diff --cached --name-only | head -20
          TOTAL_STAGED=$(git diff --cached --name-only | wc -l | tr -d ' ')
          echo "Total files staged: $TOTAL_STAGED"

          if [ "$TOTAL_STAGED" -lt 10 ]; then
            echo "❌ Error: Expected at least 10+ files to be staged"
            exit 1
          fi

      - name: Commit and tag
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          tagging_message: ${{ steps.do_version.outputs.version_tag || format('v{0}', steps.do_version.outputs.version) }}
          commit_message: "chore(version): release ${{ steps.do_version.outputs.version_tag || format('v{0}', steps.do_version.outputs.version) }}"
          # 由于我们已经显式暂存了文件，file_pattern 用于验证
          # 匹配所有 package.json 文件（根目录和所有子目录）
          file_pattern: |
            package.json
            **/package.json
            CHANGELOG.md
            CHANGELOG.zh-CN.md
          skip_dirty_check: true
          skip_fetch: false

  sync-changelog:
    needs: release
    if: always() && needs.release.result == 'success'
    uses: ./.github/workflows/sync-changelog-to-docs.yaml
    secrets: inherit
    with:
      version: v${{ needs.release.outputs.version }}

