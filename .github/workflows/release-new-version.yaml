name: Release New Version

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Specific version number (e.g., v1.6.0). Must start with "v" and be >= latest tag. If provided, bump will be ignored.'
        required: false
        type: string
      bump:
        description: 'Version bump type (only used if version is not provided)'
        required: false
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

run-name: "Release New Version - ${{ github.event.inputs.version || format('Bump: {0}', github.event.inputs.bump || 'patch') }}"

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
      actions: write
    outputs:
      version: ${{ steps.do_version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}
          fetch-depth: 0  # 获取完整的 git 历史，包括所有 tags
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.18.0
      - name: Fetch all tags
        run: |
          # 确保获取所有远程 tags，用于版本比较
          git fetch --tags --force
          echo "Available tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"
      - name: Do version release
        id: do_version
        run: |
          # 读取当前版本号
          current_version=$(node -p "require('./package.json').version")
          echo "Current version: $current_version"

          # 如果提供了具体版本号，使用它；否则使用 bump 类型
          if [ -n "${{ github.event.inputs.version }}" ]; then
            # 使用指定的版本号（保留原始格式用于显示）
            SPECIFIED_VERSION_INPUT="${{ github.event.inputs.version }}"

            # 验证版本号格式 (vX.Y.Z) - 必须带 v 前缀
            if ! echo "$SPECIFIED_VERSION_INPUT" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "❌ Error: Invalid version format. Expected format: vX.Y.Z (e.g., v1.6.0)"
              echo "   Got: $SPECIFIED_VERSION_INPUT"
              echo "   Version must start with 'v' followed by semantic versioning (major.minor.patch)"
              exit 1
            fi

            # 移除 'v' 前缀用于内部处理
            SPECIFIED_VERSION=$(echo "$SPECIFIED_VERSION_INPUT" | sed 's/^v//')

            # 获取最新的 tag（按版本号排序）
            echo "Checking latest tag..."
            LATEST_TAG=$(git tag --sort=-version:refname | head -1 || echo "")

            if [ -z "$LATEST_TAG" ]; then
              echo "ℹ No existing tags found, version $SPECIFIED_VERSION_INPUT is acceptable"
            else
              # 移除 tag 的 'v' 前缀进行比较
              LATEST_VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
              echo "Latest tag: $LATEST_TAG (version: $LATEST_VERSION)"

              # 比较版本号
              LATEST_MAJOR=$(echo "$LATEST_VERSION" | cut -d. -f1)
              LATEST_MINOR=$(echo "$LATEST_VERSION" | cut -d. -f2)
              LATEST_PATCH=$(echo "$LATEST_VERSION" | cut -d. -f3)
              SPEC_MAJOR=$(echo "$SPECIFIED_VERSION" | cut -d. -f1)
              SPEC_MINOR=$(echo "$SPECIFIED_VERSION" | cut -d. -f2)
              SPEC_PATCH=$(echo "$SPECIFIED_VERSION" | cut -d. -f3)

              # 检查新版本是否 >= 最新 tag（允许覆盖最新 tag，但不允许回退）
              VERSION_VALID=false
              if [ "$SPEC_MAJOR" -gt "$LATEST_MAJOR" ]; then
                VERSION_VALID=true
              elif [ "$SPEC_MAJOR" -eq "$LATEST_MAJOR" ]; then
                if [ "$SPEC_MINOR" -gt "$LATEST_MINOR" ]; then
                  VERSION_VALID=true
                elif [ "$SPEC_MINOR" -eq "$LATEST_MINOR" ]; then
                  if [ "$SPEC_PATCH" -ge "$LATEST_PATCH" ]; then
                    VERSION_VALID=true
                  fi
                fi
              fi

              if [ "$VERSION_VALID" != "true" ]; then
                echo "❌ Error: Cannot release version $SPECIFIED_VERSION_INPUT"
                echo ""
                echo "   Reason: Version must be greater than or equal to the latest tag"
                echo "   Latest tag: $LATEST_TAG (version: $LATEST_VERSION)"
                echo "   Specified version: $SPECIFIED_VERSION_INPUT (version: $SPECIFIED_VERSION)"
                echo ""
                echo "   ⚠ You cannot release an older version (version rollback is not allowed)."
                echo "   ⚠ You can only release the latest tag (to overwrite it) or a newer version."
                echo ""
                echo "   Allowed versions:"
                echo "   - Overwrite latest: $LATEST_TAG"
                echo "   - New versions:"
                echo "     * Major: v$((LATEST_MAJOR + 1)).0.0"
                echo "     * Minor: v$LATEST_MAJOR.$((LATEST_MINOR + 1)).0"
                echo "     * Patch: v$LATEST_MAJOR.$LATEST_MINOR.$((LATEST_PATCH + 1))"
                exit 1
              fi

              if [ "$SPEC_MAJOR" -eq "$LATEST_MAJOR" ] && [ "$SPEC_MINOR" -eq "$LATEST_MINOR" ] && [ "$SPEC_PATCH" -eq "$LATEST_PATCH" ]; then
                echo "ℹ Version $SPECIFIED_VERSION_INPUT matches latest tag $LATEST_TAG"
                echo "   This will overwrite the existing tag."
              else
                echo "✓ Version $SPECIFIED_VERSION_INPUT is greater than latest tag $LATEST_TAG"
              fi
            fi

            # 更新所有 package.json 中的版本号
            echo "Updating version to $SPECIFIED_VERSION in all packages..."
            if ! pnpm -r exec -- npm version "$SPECIFIED_VERSION" --no-git-tag-version; then
              echo "❌ Error: Failed to update version in some packages"
              exit 1
            fi

            # 验证根目录和主要包的版本号都已更新
            echo "Verifying version updates in key packages..."
            ROOT_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
            if [ -z "$ROOT_VERSION" ]; then
              echo "❌ Error: Failed to read root package.json version"
              exit 1
            fi
            if [ "$ROOT_VERSION" != "$SPECIFIED_VERSION" ]; then
              echo "❌ Error: Root package.json version is $ROOT_VERSION, expected $SPECIFIED_VERSION"
              exit 1
            fi
            echo "✓ Root package.json version verified: $ROOT_VERSION"

            # 检查几个关键包的版本号（使用更可靠的方法）
            KEY_PACKAGES=("packages/client/package.json" "packages/module-workflow/package.json" "apps/web/package.json")
            for pkg in "${KEY_PACKAGES[@]}"; do
              if [ -f "$pkg" ]; then
                # 使用 grep 和 sed 直接读取版本号（更可靠）
                PKG_VERSION=$(grep -E '^\s*"version"\s*:\s*"' "$pkg" | head -1 | sed -E 's/.*"version"\s*:\s*"([^"]+)".*/\1/' || echo "")
                if [ -z "$PKG_VERSION" ]; then
                  echo "⚠ Warning: Could not extract version from $pkg using grep, trying node..."
                  # 备用方法：使用 node（需要正确的路径）
                  PKG_VERSION=$(cd "$(dirname "$pkg")" && node -p "require('./$(basename "$pkg")').version" 2>/dev/null || echo "")
                fi
                if [ -z "$PKG_VERSION" ]; then
                  echo "❌ Error: Could not read version from $pkg"
                  echo "File content (first 10 lines):"
                  head -10 "$pkg"
                  exit 1
                fi
                if [ "$PKG_VERSION" != "$SPECIFIED_VERSION" ]; then
                  echo "❌ Error: $pkg version is $PKG_VERSION, expected $SPECIFIED_VERSION"
                  exit 1
                fi
                echo "✓ $pkg version verified: $PKG_VERSION"
              else
                echo "⚠ Warning: $pkg does not exist, skipping verification"
              fi
            done

            # 统计所有更新的 package.json 文件
            UPDATED_COUNT=$(git diff --name-only HEAD | grep -c "package.json$" || echo "0")
            echo "✓ Updated $UPDATED_COUNT package.json files to version $SPECIFIED_VERSION"

            version="$SPECIFIED_VERSION"
            echo "✓ All packages updated to version: $version"
          else
            # 使用 bump 类型
            bump="${{ github.event.inputs.bump || 'patch' }}"
            echo "Using bump type: $bump"

            if [ "$bump" = "major" ]; then
              if ! pnpm -r exec -- npm version major --no-git-tag-version; then
                echo "❌ Error: Failed to bump version in some packages"
                exit 1
              fi
              version=$(npm version major --no-git-tag-version)
            elif [ "$bump" = "minor" ]; then
              if ! pnpm -r exec -- npm version minor --no-git-tag-version; then
                echo "❌ Error: Failed to bump version in some packages"
                exit 1
              fi
              version=$(npm version minor --no-git-tag-version)
            else
              if ! pnpm -r exec -- npm version patch --no-git-tag-version; then
                echo "❌ Error: Failed to bump version in some packages"
                exit 1
              fi
              version=$(npm version patch --no-git-tag-version)
            fi

            # 验证根目录版本号
            ROOT_VERSION=$(node -p "require('./package.json').version")
            if [ "$ROOT_VERSION" != "$version" ]; then
              echo "❌ Error: Root package.json version mismatch. Expected $version, got $ROOT_VERSION"
              exit 1
            fi

            # 统计所有更新的 package.json 文件
            UPDATED_COUNT=$(git diff --name-only HEAD | grep -c "package.json$" || echo "0")
            echo "✓ Version bumped to: $version ($UPDATED_COUNT package.json files updated)"
          fi

          echo "New version: $version"
          # 输出版本号（不带 v 前缀，用于内部处理）
          echo "version=$version" >> $GITHUB_OUTPUT
          # 输出带 v 前缀的版本号（用于创建 tag）
          echo "version_tag=v$version" >> $GITHUB_OUTPUT
          echo "current_version=$current_version" >> $GITHUB_OUTPUT
          echo "::notice title=Version Updated::New version: $version"

      - name: Fetch all tags
        run: |
          # 确保获取所有远程 tags
          git fetch --tags --force
          echo "Available tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"

      - name: Generate changelog
        id: generate_changelog
        run: |
          set -e  # 如果任何命令失败，立即退出

          current_version="${{ steps.do_version.outputs.current_version }}"
          new_version="${{ steps.do_version.outputs.version }}"

          # 获取上一个 tag（排除当前要发布的版本 tag，如果存在）
          # 按版本号排序，获取最新的 tag
          previous_tag=$(git tag --sort=-version:refname | grep -v "^v${new_version}$" | head -1 || echo "")

          # 如果还是找不到，尝试使用 git describe（但排除当前版本）
          if [ -z "$previous_tag" ]; then
            previous_tag=$(git describe --tags --abbrev=0 --exclude="v${new_version}" 2>/dev/null || echo "")
          fi

          echo "Generating changelog for version: $new_version"

          # 检查 [Unreleased] 内容是否存在
          HAS_UNRELEASED_EN=$(grep -q "^## \[Unreleased\]" CHANGELOG.md && echo "yes" || echo "no")
          HAS_UNRELEASED_ZH=$(grep -q "^## \[未发布\]" CHANGELOG.zh-CN.md && echo "yes" || echo "no")
          echo "  [Unreleased] content available: EN=$HAS_UNRELEASED_EN, ZH=$HAS_UNRELEASED_ZH"

          CHANGELOG_GENERATED=false

          if [ -n "$previous_tag" ]; then
            echo "  From tag: $previous_tag"
            echo "  To version: v$new_version"

            # 先尝试从 git commits 生成
            echo "  Attempting to generate from git commits..."
            if node scripts/generate-changelog.mjs "$new_version" "$previous_tag" 2>&1; then
              # 检查是否成功生成了版本条目
              if grep -q "## \[$new_version\]" CHANGELOG.md; then
                echo "  ✓ Successfully generated from git commits"
                CHANGELOG_GENERATED=true
              else
                echo "  ⚠ Generated but no version entry found, may have no commits"
              fi
            else
              echo "  ⚠ Failed to generate from git commits"
            fi

            # 如果从 git commits 生成失败或没有内容，使用 [Unreleased] 内容
            if [ "$CHANGELOG_GENERATED" != "true" ]; then
              if [ "$HAS_UNRELEASED_EN" = "yes" ] || [ "$HAS_UNRELEASED_ZH" = "yes" ]; then
                echo "  Using [Unreleased] content to generate changelog..."
                CHANGELOG_USE_UNRELEASED=true node scripts/generate-changelog.mjs "$new_version" "$previous_tag" || {
                  echo "  ❌ Failed to generate changelog from [Unreleased] content"
                  exit 1
                }
                CHANGELOG_GENERATED=true
              else
                echo "  ❌ No [Unreleased] content available and no git commits found"
                exit 1
              fi
            fi
          else
            echo "  No previous tag found"
            echo "  Using [Unreleased] content to generate changelog"
            # 如果没有之前的 tag，使用 [Unreleased] 内容
            CHANGELOG_USE_UNRELEASED=true node scripts/generate-changelog.mjs "$new_version" || {
              echo "  ❌ Failed to generate changelog from [Unreleased] content"
              exit 1
            }
            CHANGELOG_GENERATED=true
          fi

          # 验证生成的文件是否存在且有内容
          if [ ! -f "CHANGELOG.md" ]; then
            echo "❌ Error: CHANGELOG.md was not generated"
            exit 1
          fi

          if [ ! -f "CHANGELOG.zh-CN.md" ]; then
            echo "❌ Error: CHANGELOG.zh-CN.md was not generated"
            exit 1
          fi

          # 检查是否包含新版本的条目
          if ! grep -q "## \[$new_version\]" CHANGELOG.md; then
            echo "❌ Error: CHANGELOG.md does not contain entry for version $new_version"
            echo "First 50 lines of CHANGELOG.md:"
            head -50 CHANGELOG.md
            exit 1
          fi

          if ! grep -q "## \[$new_version\]" CHANGELOG.zh-CN.md; then
            echo "❌ Error: CHANGELOG.zh-CN.md does not contain entry for version $new_version"
            echo "First 50 lines of CHANGELOG.zh-CN.md:"
            head -50 CHANGELOG.zh-CN.md
            exit 1
          fi

          # 检查是否有变更（相对于 HEAD）
          if git diff --quiet HEAD CHANGELOG.md CHANGELOG.zh-CN.md; then
            echo "⚠ Warning: No changes detected in CHANGELOG files"
            echo "This may indicate the changelog was already up to date"
            echo "changelog_updated=false" >> $GITHUB_OUTPUT
          else
            echo "✓ Changelog generated successfully with changes"
            echo "Changes preview:"
            git diff --stat HEAD CHANGELOG.md CHANGELOG.zh-CN.md
            echo "changelog_updated=true" >> $GITHUB_OUTPUT
          fi

      - name: Update workflow run name
        env:
          NEW_NAME: "Release New Version - ${{ github.event.inputs.version || format('Bump: {0}', github.event.inputs.bump || 'patch') }} → ${{ steps.do_version.outputs.version }}"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
        run: |
          node -e "
            const https = require('https');
            const newName = process.env.NEW_NAME;
            const token = process.env.GITHUB_TOKEN;
            const repo = process.env.REPOSITORY;
            const runId = process.env.RUN_ID;
            const data = JSON.stringify({ display_title: newName });
            const options = {
              hostname: 'api.github.com',
              path: '/repos/' + repo + '/actions/runs/' + runId,
              method: 'PATCH',
              headers: {
                'Accept': 'application/vnd.github+json',
                'Authorization': 'Bearer ' + token,
                'X-GitHub-Api-Version': '2022-11-28',
                'Content-Type': 'application/json',
                'Content-Length': data.length
              }
            };
            const req = https.request(options, (res) => {
              let body = '';
              res.on('data', (chunk) => { body += chunk; });
              res.on('end', () => {
                if (res.statusCode === 200 || res.statusCode === 204) {
                  console.log('✓ Workflow run name updated successfully');
                } else {
                  console.log('⚠ Failed to update run name (status: ' + res.statusCode + '), but continuing...');
                  console.log('Response:', body);
                }
              });
            });
            req.on('error', (e) => {
              console.log('⚠ Error updating run name:', e.message, ', but continuing...');
            });
            req.write(data);
            req.end();
          "

      - name: Verify files before commit
        run: |
          NEW_VERSION="${{ steps.do_version.outputs.version }}"

          echo "=== Verifying files before commit ==="

          # 验证关键文件是否存在
          if [ ! -f "CHANGELOG.md" ]; then
            echo "❌ Error: CHANGELOG.md does not exist"
            exit 1
          fi
          if [ ! -f "CHANGELOG.zh-CN.md" ]; then
            echo "❌ Error: CHANGELOG.zh-CN.md does not exist"
            exit 1
          fi

          # 检查 CHANGELOG 是否包含新版本条目
          if ! grep -q "## \[$NEW_VERSION\]" CHANGELOG.md; then
            echo "❌ Error: CHANGELOG.md does not contain entry for version $NEW_VERSION"
            echo "Available versions in CHANGELOG.md:"
            grep "^## \[" CHANGELOG.md | head -5
            exit 1
          fi

          if ! grep -q "## \[$NEW_VERSION\]" CHANGELOG.zh-CN.md; then
            echo "❌ Error: CHANGELOG.zh-CN.md does not contain entry for version $NEW_VERSION"
            echo "Available versions in CHANGELOG.zh-CN.md:"
            grep "^## \[" CHANGELOG.zh-CN.md | head -5
            exit 1
          fi

          # 显示文件变更状态
          echo ""
          echo "=== File changes status ==="
          echo "All package.json files changed:"
          git diff --name-only HEAD | grep "package.json$" | head -20 || echo "  (no package.json changes found)"
          TOTAL_PKG_CHANGES=$(git diff --name-only HEAD | grep -c "package.json$" || echo "0")
          echo "Total package.json files changed: $TOTAL_PKG_CHANGES"

          # 验证至少更新了根目录和主要包的 package.json
          # 通常应该有 90+ 个 package.json 文件（根目录 + packages/* + apps/*）
          if [ "$TOTAL_PKG_CHANGES" -lt 10 ]; then
            echo "❌ Error: Expected at least 10+ package.json files to be updated, but only $TOTAL_PKG_CHANGES found"
            echo "This indicates that not all packages were updated correctly"
            echo "Please check if pnpm -r exec command succeeded for all packages"
            exit 1
          fi

          # 验证根目录 package.json 的版本号是否正确（而不是检查是否在 diff 中）
          # 因为版本更新步骤已经更新了它，所以它可能已经在工作区中
          ROOT_PKG_VERSION=$(grep -E '^\s*"version"\s*:\s*"' package.json | head -1 | sed -E 's/.*"version"\s*:\s*"([^"]+)".*/\1/' || echo "")
          if [ -z "$ROOT_PKG_VERSION" ]; then
            echo "⚠ Warning: Could not read root package.json version"
          elif [ "$ROOT_PKG_VERSION" != "$NEW_VERSION" ]; then
            echo "❌ Error: Root package.json version is $ROOT_PKG_VERSION, expected $NEW_VERSION"
            exit 1
          else
            echo "✓ Root package.json version verified: $ROOT_PKG_VERSION"
          fi

          echo ""
          echo "CHANGELOG.md changes:"
          git diff --stat HEAD CHANGELOG.md 2>/dev/null || echo "  (no changes)"

          echo ""
          echo "CHANGELOG.zh-CN.md changes:"
          git diff --stat HEAD CHANGELOG.zh-CN.md 2>/dev/null || echo "  (no changes)"

          # 显示 CHANGELOG 中新版本条目的预览
          echo ""
          echo "=== CHANGELOG.md entry preview for $NEW_VERSION ==="
          grep -A 10 "## \[$NEW_VERSION\]" CHANGELOG.md | head -15

          echo ""
          echo "=== CHANGELOG.zh-CN.md entry preview for $NEW_VERSION ==="
          grep -A 10 "## \[$NEW_VERSION\]" CHANGELOG.zh-CN.md | head -15

          echo ""
          echo "✓ All files verified successfully"

      - name: Stage all changed files
        run: |
          # 显式添加所有需要提交的文件
          echo "Staging all changed files..."

          # 添加根目录 package.json
          if [ -f "package.json" ]; then
            git add package.json
            echo "✓ Added package.json"
          fi

          # 添加所有子目录的 package.json 文件（排除 node_modules 和 dist）
          find . \
            -type d \( -name node_modules -o -name dist \) -prune \
            -o -name package.json -type f -print | \
          while IFS= read -r file; do
            if [ "$file" != "./package.json" ]; then
              git add "$file"
            fi
          done
          echo "✓ Added all package.json files"

          # 添加 CHANGELOG 文件
          git add CHANGELOG.md CHANGELOG.zh-CN.md
          echo "✓ Added CHANGELOG files"

          # 显示将要提交的文件
          echo ""
          echo "Files staged for commit:"
          git diff --cached --name-only | head -20
          TOTAL_STAGED=$(git diff --cached --name-only | wc -l | tr -d ' ')
          echo "Total files staged: $TOTAL_STAGED"

          if [ "$TOTAL_STAGED" -lt 10 ]; then
            echo "❌ Error: Expected at least 10+ files to be staged"
            exit 1
          fi

      - name: Commit and tag
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          tagging_message: ${{ steps.do_version.outputs.version_tag || format('v{0}', steps.do_version.outputs.version) }}
          commit_message: "chore(version): release ${{ steps.do_version.outputs.version_tag || format('v{0}', steps.do_version.outputs.version) }}"
          # 由于我们已经显式暂存了文件，file_pattern 用于验证
          # 匹配所有 package.json 文件（根目录和所有子目录）
          file_pattern: |
            package.json
            **/package.json
            CHANGELOG.md
            CHANGELOG.zh-CN.md
          skip_dirty_check: true
          skip_fetch: false

  sync-changelog:
    needs: release
    if: always() && needs.release.result == 'success'
    uses: ./.github/workflows/sync-changelog-to-docs.yaml
    secrets: inherit
    with:
      version: v${{ needs.release.outputs.version }}

